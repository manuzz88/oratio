"""
Data Operations for ORATIO
Auto-generated by AutonomousOratio system
"""

# Operations will be appended here automatically


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:08:20

import os

def create_file(filepath: str, content: str = '') -> None:
    """
    Crea un nuovo file nel file system con il contenuto specificato.
    
    Args:
        filepath: Path completo del file da creare.
        content: Contenuto da scrivere nel file. Default è una stringa vuota.
    
    Raises:
        FileExistsError: Se il file esiste già.
        OSError: Se si verifica un errore durante la creazione del file.
    """
    if os.path.exists(filepath):
        raise FileExistsError(f"Il file {filepath} esiste già.")
    
    try:
        with open(filepath, 'w') as file:
            file.write(content)
    except OSError as e:
        raise OSError(f"Errore nella creazione del file {filepath}: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:08:34

import shutil
import os

def copy_file(source: str, destination: str) -> None:
    """
    Copia un file esistente da una posizione a un'altra.
    
    Args:
        source: Path al file sorgente da copiare.
        destination: Path di destinazione dove il file sarà copiato.
    
    Raises:
        FileNotFoundError: Se il file sorgente non esiste.
        IOError: Se si verifica un errore durante la copia del file.
        ValueError: Se il percorso di destinazione è una directory.
    """
    if os.path.isdir(destination):
        raise ValueError(f"Il percorso di destinazione '{destination}' è una directory. Specificare un file.")
    
    try:
        shutil.copy2(source, destination)
    except FileNotFoundError:
        raise FileNotFoundError(f"File sorgente '{source}' non trovato.")
    except IOError as e:
        raise IOError(f"Errore durante la copia del file: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:08:54

import os

def delete_file(filepath: str) -> None:
    """
    Elimina un file dal file system.
    
    Args:
        filepath: Path al file da eliminare.
    
    Raises:
        FileNotFoundError: Se il file non esiste.
        PermissionError: Se non si hanno i permessi per eliminare il file.
        OSError: Se si verifica un errore durante l'eliminazione del file.
    """
    try:
        if not os.path.isfile(filepath):
            raise FileNotFoundError(f"File {filepath} non trovato.")
        
        os.remove(filepath)
        print(f"File {filepath} eliminato con successo.")
    
    except FileNotFoundError as fnf_error:
        raise FileNotFoundError(fnf_error)
    except PermissionError as perm_error:
        raise PermissionError(f"Permesso negato per eliminare il file {filepath}: {perm_error}")
    except OSError as os_error:
        raise OSError(f"Errore durante l'eliminazione del file {filepath}: {os_error}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:09:13

import requests
from bs4 import BeautifulSoup
from typing import Dict, Any

def scrape_website(url: str) -> Dict[str, Any]:
    """
    Estrae dati da una pagina web e restituisce il contenuto HTML
    
    Args:
        url: URL della pagina web da cui estrarre i dati
    
    Returns:
        Dict con 'content' (stringa HTML) e 'metadata'
    
    Raises:
        ValueError: Se l'URL non è valido
        ConnectionError: Se non riesce a connettersi al sito
        Exception: Se si verifica un errore durante il recupero dei dati
    """
    try:
        response = requests.get(url)
        response.raise_for_status()  # Solleva un'eccezione per codici di stato HTTP 4xx/5xx
        content = response.text
        return {
            "content": content,
            "metadata": {
                "url": url,
                "status_code": response.status_code,
                "content_length": len(content)
            }
        }
    except requests.exceptions.MissingSchema:
        raise ValueError(f"URL non valido: {url}")
    except requests.exceptions.RequestException as e:
        raise ConnectionError(f"Errore di connessione: {e}")
    except Exception as e:
        raise Exception(f"Errore durante il recupero dei dati: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:09:30

def load_csv(filepath: str, **kwargs) -> dict:
    """
    Carica file CSV e ritorna dati
    
    Args:
        filepath: Path al file CSV
        **kwargs: Opzioni pandas (delimiter, encoding, etc)
    
    Returns:
        Dict con 'data' (DataFrame) e 'metadata'
    
    Raises:
        FileNotFoundError: Se file non esiste
        ValueError: Se CSV non valido
    """
    import pandas as pd
    
    try:
        df = pd.read_csv(filepath, **kwargs)
        return {
            "data": df,
            "rows": len(df),
            "columns": list(df.columns),
            "metadata": {"filepath": filepath}
        }
    except FileNotFoundError:
        raise FileNotFoundError(f"File {filepath} non trovato")
    except pd.errors.EmptyDataError:
        raise ValueError("Il file CSV è vuoto")
    except pd.errors.ParserError:
        raise ValueError("Errore di parsing nel file CSV")
    except Exception as e:
        raise ValueError(f"Errore lettura CSV: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:11:47

def file_create(filepath: str, content: str = "") -> None:
    """
    Crea un nuovo file con il contenuto specificato.
    
    Args:
        filepath: Il percorso del file da creare.
        content: Il contenuto da scrivere nel file (default è una stringa vuota).
    
    Raises:
        FileExistsError: Se il file esiste già.
        IOError: Se si verifica un errore durante la scrittura del file.
    """
    import os

    if os.path.exists(filepath):
        raise FileExistsError(f"Il file {filepath} esiste già.")
    
    try:
        with open(filepath, 'w') as file:
            file.write(content)
    except IOError as e:
        raise IOError(f"Errore durante la creazione del file: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:12:03

import os

def file_delete(filepath: str) -> None:
    """
    Elimina un file esistente.
    
    Args:
        filepath: Path al file da eliminare.
    
    Raises:
        FileNotFoundError: Se il file non esiste.
        OSError: Se si verifica un errore durante l'eliminazione del file.
    """
    try:
        if not os.path.isfile(filepath):
            raise FileNotFoundError(f"File {filepath} non trovato.")
        
        os.remove(filepath)
    except OSError as e:
        raise OSError(f"Errore durante l'eliminazione del file {filepath}: {e}")

# Test della funzione
if __name__ == "__main__":
    import tempfile

    # Creazione di un file temporaneo per il test
    temp_file = tempfile.NamedTemporaryFile(delete=False)
    temp_file.close()

    # Test di eliminazione del file
    try:
        file_delete(temp_file.name)
        print(f"File {temp_file.name} eliminato con successo.")
    except Exception as e:
        print(e)


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:12:29

import shutil
import os

def file_copy(source: str, destination: str) -> None:
    """
    Copia un file da una posizione a un'altra.
    
    Args:
        source: Path al file sorgente da copiare.
        destination: Path di destinazione dove il file sarà copiato.
    
    Raises:
        FileNotFoundError: Se il file sorgente non esiste.
        IsADirectoryError: Se la destinazione è una directory.
        IOError: Se si verifica un errore durante la copia del file.
    """
    if not os.path.isfile(source):
        raise FileNotFoundError(f"File sorgente {source} non trovato.")
    
    try:
        shutil.copy2(source, destination)
    except IsADirectoryError:
        raise IsADirectoryError(f"La destinazione {destination} è una directory.")
    except IOError as e:
        raise IOError(f"Errore durante la copia del file: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:12:52

def load_csv(filepath: str, **kwargs) -> dict:
    """
    Carica file CSV e ritorna dati.
    
    Args:
        filepath: Path al file CSV.
        **kwargs: Opzioni pandas (delimiter, encoding, etc).
    
    Returns:
        Dict con 'data' (DataFrame) e 'metadata'.
    
    Raises:
        FileNotFoundError: Se il file non esiste.
        ValueError: Se il CSV non è valido.
    """
    import pandas as pd
    
    try:
        df = pd.read_csv(filepath, **kwargs)
        return {
            "data": df,
            "rows": len(df),
            "columns": list(df.columns),
            "metadata": {"filepath": filepath}
        }
    except FileNotFoundError:
        raise FileNotFoundError(f"File {filepath} non trovato")
    except pd.errors.EmptyDataError:
        raise ValueError("Il file CSV è vuoto")
    except pd.errors.ParserError:
        raise ValueError("Errore di parsing nel file CSV")
    except Exception as e:
        raise ValueError(f"Errore lettura CSV: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:13:14

import pandas as pd
from typing import Any, Dict

def save_csv(data: pd.DataFrame, filepath: str, **kwargs) -> None:
    """
    Salva dati in formato CSV.
    
    Args:
        data: DataFrame da salvare.
        filepath: Path dove salvare il file CSV.
        **kwargs: Opzioni pandas (delimiter, encoding, etc).
    
    Raises:
        ValueError: Se i dati non sono un DataFrame.
        IOError: Se si verifica un errore durante il salvataggio del file.
    """
    if not isinstance(data, pd.DataFrame):
        raise ValueError("I dati devono essere un DataFrame di pandas.")
    
    try:
        data.to_csv(filepath, **kwargs)
    except IOError as e:
        raise IOError(f"Errore durante il salvataggio del file CSV: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:13:31

import json
from typing import Any, Dict

def load_json(filepath: str) -> Dict[str, Any]:
    """
    Carica file JSON e ritorna dati
    
    Args:
        filepath: Path al file JSON
    
    Returns:
        Dict con i dati caricati e 'metadata'
    
    Raises:
        FileNotFoundError: Se il file non esiste
        ValueError: Se il file JSON non è valido
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as file:
            data = json.load(file)
            return {
                "data": data,
                "metadata": {"filepath": filepath}
            }
    except FileNotFoundError:
        raise FileNotFoundError(f"File {filepath} non trovato")
    except json.JSONDecodeError:
        raise ValueError(f"Errore nel caricamento del file JSON: {filepath} non è un JSON valido")
    except Exception as e:
        raise ValueError(f"Errore lettura JSON: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:13:53

import json
from typing import Any, Dict

def save_json(filepath: str, data: Any) -> None:
    """
    Salva dati in formato JSON in un file specificato.
    
    Args:
        filepath: Path al file JSON dove salvare i dati.
        data: Dati da salvare, che possono essere di qualsiasi tipo serializzabile in JSON.
    
    Raises:
        FileNotFoundError: Se il percorso della cartella non esiste.
        ValueError: Se i dati non possono essere serializzati in JSON.
        IOError: Se si verifica un errore durante la scrittura del file.
    """
    try:
        with open(filepath, 'w', encoding='utf-8') as json_file:
            json.dump(data, json_file, ensure_ascii=False, indent=4)
    except FileNotFoundError:
        raise FileNotFoundError(f"La cartella per il file {filepath} non esiste.")
    except ValueError as ve:
        raise ValueError(f"I dati forniti non possono essere serializzati in JSON: {ve}")
    except IOError as ioe:
        raise IOError(f"Errore durante la scrittura del file JSON: {ioe}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:14:22

import requests
from typing import Dict, Any

def http_get(url: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
    """
    Esegue una richiesta GET a un'API e ritorna i dati ricevuti.
    
    Args:
        url: L'URL dell'API da interrogare.
        params: Un dizionario di parametri da inviare nella richiesta (opzionale).
    
    Returns:
        Un dizionario contenente i dati ricevuti e lo stato della risposta.
    
    Raises:
        ValueError: Se l'URL non è valido o se la risposta non è valida.
        requests.exceptions.RequestException: Se si verifica un errore nella richiesta.
    """
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # Solleva un'eccezione per codici di stato HTTP 4xx/5xx
        
        return {
            "data": response.json(),
            "status_code": response.status_code,
            "url": response.url
        }
    except requests.exceptions.MissingSchema:
        raise ValueError(f"URL non valido: {url}")
    except requests.exceptions.RequestException as e:
        raise ValueError(f"Errore nella richiesta GET: {e}")
    except ValueError as e:
        raise ValueError(f"Errore nel parsing della risposta JSON: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:14:45

import requests
from typing import Dict, Any

def http_post(url: str, data: Dict[str, Any], headers: Dict[str, str] = None) -> Dict[str, Any]:
    """
    Esegue una richiesta POST a un'API e ritorna la risposta.

    Args:
        url: L'URL dell'API a cui inviare la richiesta POST.
        data: I dati da inviare nel corpo della richiesta.
        headers: Eventuali intestazioni da includere nella richiesta.

    Returns:
        Dict con 'status_code' e 'response_data'.

    Raises:
        ValueError: Se l'URL è vuoto o se la richiesta fallisce.
        requests.exceptions.RequestException: Se si verifica un errore durante la richiesta.
    """
    if not url:
        raise ValueError("L'URL non può essere vuoto.")

    try:
        response = requests.post(url, json=data, headers=headers)
        response.raise_for_status()  # Solleva un'eccezione per codici di stato HTTP 4xx/5xx
        return {
            "status_code": response.status_code,
            "response_data": response.json()  # Presupponendo che la risposta sia in formato JSON
        }
    except requests.exceptions.RequestException as e:
        raise ValueError(f"Errore nella richiesta POST: {e}")


# Auto-generated by AutonomousOratio
# Generated: 2025-11-13 15:15:00

def loop(data: list, operation: callable) -> list:
    """
    Esegue un'operazione ripetuta su una serie di dati.
    
    Args:
        data: Lista di dati su cui eseguire l'operazione.
        operation: Funzione che definisce l'operazione da eseguire su ogni elemento della lista.
    
    Returns:
        Lista dei risultati ottenuti applicando l'operazione a ciascun elemento.
    
    Raises:
        TypeError: Se 'data' non è una lista o 'operation' non è una funzione.
        Exception: Se si verifica un errore durante l'esecuzione dell'operazione.
    """
    if not isinstance(data, list):
        raise TypeError("Il parametro 'data' deve essere una lista.")
    if not callable(operation):
        raise TypeError("Il parametro 'operation' deve essere una funzione.")

    results = []
    for item in data:
        try:
            result = operation(item)
            results.append(result)
        except Exception as e:
            raise Exception(f"Errore durante l'esecuzione dell'operazione: {e}")

    return results
